{"ast":null,"code":"const {\n  PNG\n} = require('pngjs');\nconst {\n  getShasumData\n} = require('./encryption');\nconst {\n  countBytesForNRgbBytes,\n  isAlphaByte,\n  isRgbByte,\n  recombineRgbAndAlpha,\n  splitRgbAndAlpha\n} = require('./png');\nconst {\n  BYTE_SIZE,\n  LENGTH_BYTES,\n  SHASUM_BYTES\n} = require('./defaults');\nconst getLengthData = message => {\n  const lengthHex = message.length.toString(16);\n  const lengthBuffer = Buffer.from(lengthHex.length % 2 ? `0${lengthHex}` : lengthHex, 'hex');\n  const pad = Buffer.alloc(LENGTH_BYTES - lengthBuffer.length);\n  return Buffer.concat([pad, lengthBuffer], LENGTH_BYTES);\n};\nconst getBit = data => i => {\n  const byteIndex = Math.floor(i / BYTE_SIZE);\n  const bitIndex = i % BYTE_SIZE;\n  const byte = data[byteIndex];\n  const shiftDistance = BYTE_SIZE - 1 - bitIndex;\n  return (byte >> shiftDistance) % 2;\n};\nconst addDataToByte = data => (byte, i) => byte >> 1 << 1 | getBit(data)(i);\nconst embedData = _ref => {\n  let [data, bed] = _ref;\n  return bed.map(addDataToByte(data));\n};\nconst store = (imageData, message) => {\n  const bytesAvailable = imageData.length;\n  const bytesToStore = LENGTH_BYTES + SHASUM_BYTES + message.length;\n  const bytesRequired = countBytesForNRgbBytes(bytesToStore);\n  if (bytesAvailable < bytesRequired) throw new Error('Image is not large enough to store message');\n  const lengthData = getLengthData(message);\n  const shasumData = getShasumData(message);\n  const bytesToUse = imageData.slice(0, bytesRequired);\n  const bytesToLeave = imageData.slice(bytesRequired);\n  const [rgb, alpha] = splitRgbAndAlpha(bytesToUse);\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE;\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE;\n  const bytesToUseWithLengthData = rgb.slice(0, lengthDataSize);\n  const bytesToUseWithShasumData = rgb.slice(lengthDataSize, lengthDataSize + shasumDataSize);\n  const bytesToUseWithMessageData = rgb.slice(lengthDataSize + shasumDataSize);\n  const embeddedData = Buffer.concat([[lengthData, bytesToUseWithLengthData], [shasumData, bytesToUseWithShasumData], [message, bytesToUseWithMessageData]].map(embedData), rgb.length);\n  const recombined = recombineRgbAndAlpha(embeddedData, alpha);\n  const adjustedImageData = Buffer.concat([recombined, bytesToLeave], bytesAvailable);\n  return adjustedImageData;\n};\nconst conceal = (image, message, encoding) => {\n  const messageBuffer = Buffer.isBuffer(message) ? message : Buffer.from(message, encoding);\n  const png = PNG.sync.read(image);\n  const data = store(png.data, messageBuffer);\n  const adjustedPng = Object.assign({}, png, {\n    data\n  });\n  return PNG.sync.write(adjustedPng);\n};\nmodule.exports = {\n  conceal\n};","map":{"version":3,"names":["PNG","require","getShasumData","countBytesForNRgbBytes","isAlphaByte","isRgbByte","recombineRgbAndAlpha","splitRgbAndAlpha","BYTE_SIZE","LENGTH_BYTES","SHASUM_BYTES","getLengthData","message","lengthHex","length","toString","lengthBuffer","Buffer","from","pad","alloc","concat","getBit","data","i","byteIndex","Math","floor","bitIndex","byte","shiftDistance","addDataToByte","embedData","_ref","bed","map","store","imageData","bytesAvailable","bytesToStore","bytesRequired","Error","lengthData","shasumData","bytesToUse","slice","bytesToLeave","rgb","alpha","lengthDataSize","shasumDataSize","bytesToUseWithLengthData","bytesToUseWithShasumData","bytesToUseWithMessageData","embeddedData","recombined","adjustedImageData","conceal","image","encoding","messageBuffer","isBuffer","png","sync","read","adjustedPng","Object","assign","write","module","exports"],"sources":["D:/YairGabay/8200/GitHub/Messenger/client/node_modules/steggy-noencrypt/lib/conceal.js"],"sourcesContent":["const { PNG } = require('pngjs')\nconst { getShasumData } = require('./encryption')\nconst {\n  countBytesForNRgbBytes,\n  isAlphaByte,\n  isRgbByte,\n  recombineRgbAndAlpha,\n  splitRgbAndAlpha,\n} = require('./png')\nconst {\n  BYTE_SIZE,\n  LENGTH_BYTES,\n  SHASUM_BYTES,\n} = require('./defaults')\n\nconst getLengthData = message => {\n  const lengthHex = message.length.toString(16)\n  const lengthBuffer = Buffer.from(lengthHex.length % 2 ? `0${lengthHex}` : lengthHex, 'hex')\n  const pad = Buffer.alloc(LENGTH_BYTES - lengthBuffer.length)\n  return Buffer.concat([pad, lengthBuffer], LENGTH_BYTES)\n}\n\nconst getBit = data => i => {\n  const byteIndex = Math.floor(i / BYTE_SIZE)\n  const bitIndex = i % BYTE_SIZE\n\n  const byte = data[byteIndex]\n  const shiftDistance = (BYTE_SIZE - 1) - bitIndex\n  return (byte >> shiftDistance) % 2\n}\n\nconst addDataToByte = data => (byte, i) =>\n  ((byte >> 1) << 1) | getBit(data)(i)\n\nconst embedData = ([data, bed]) => bed.map(addDataToByte(data))\n\nconst store = (imageData, message) => {\n  const bytesAvailable = imageData.length\n  const bytesToStore = LENGTH_BYTES + SHASUM_BYTES + message.length\n  const bytesRequired = countBytesForNRgbBytes(bytesToStore)\n\n  if (bytesAvailable < bytesRequired)\n    throw new Error('Image is not large enough to store message')\n\n  const lengthData = getLengthData(message)\n  const shasumData = getShasumData(message)\n\n  const bytesToUse = imageData.slice(0, bytesRequired)\n  const bytesToLeave = imageData.slice(bytesRequired)\n\n  const [ rgb, alpha ] = splitRgbAndAlpha(bytesToUse)\n\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE\n\n  const bytesToUseWithLengthData = rgb.slice(0, lengthDataSize)\n  const bytesToUseWithShasumData = rgb.slice(lengthDataSize, lengthDataSize + shasumDataSize)\n  const bytesToUseWithMessageData = rgb.slice(lengthDataSize + shasumDataSize)\n\n  const embeddedData = Buffer.concat([\n    [lengthData, bytesToUseWithLengthData],\n    [shasumData, bytesToUseWithShasumData],\n    [message, bytesToUseWithMessageData],\n  ].map(embedData), rgb.length)\n\n  const recombined = recombineRgbAndAlpha(embeddedData, alpha)\n  const adjustedImageData = Buffer.concat([recombined, bytesToLeave], bytesAvailable)\n\n  return adjustedImageData\n}\n\nconst conceal = (image, message, encoding) => {\n  const messageBuffer = Buffer.isBuffer(message)\n    ? message\n    : Buffer.from(message, encoding)\n\n  const png = PNG.sync.read(image)\n  const data = store(png.data, messageBuffer)\n  const adjustedPng = Object.assign({}, png, { data })\n\n  return PNG.sync.write(adjustedPng)\n}\n\nmodule.exports = {\n  conceal,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}